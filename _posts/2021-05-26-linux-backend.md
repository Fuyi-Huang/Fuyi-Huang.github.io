---
title: 后端开发技术栈总结
tags: 
  - programming
  - resume
article_header:
 type: cover
 image:
  src: assets/images/header_images/zelda.jpg
mathjax: true
mathjax_autoNumber: true

---



## 前言

最近在面试，才发现自己的基础和技术栈多么不足。萌生了总结一下自己的技术栈的想法。



## 目录

### 编程基础

* 语言

* 数据结构

* [算法](# 算法)

* 网络

* [操作系统](#操作系统)

  

### 技术栈

* 存储





## 一、编程基础

### 语言



### 数据结构



### 算法

#### 动态规划

动态规划写起来有两种，一个是自顶向下，也叫记忆化搜索，一般用递归实现的；一个是自底向上，递推实现。

递推实现也分两种，从高往低递推，比如背包DP，最长回文字符串DP；另外常见的都是从低往高递推。



### 网络



### 操作系统

* 进程

* 线程

* CPU调度

* 内存管理

* I/O

* 文件系统



#### 内存管理

[【精校中英字幕】2015 CMU 15-213 CSAPP 深入理解计算机系统 课程视频_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1iW411d7hd?p=17)

虚拟内存：当一个进程运行的时候，给该进程分配的内存空间是虚拟内容空间，当代码调用malloc申请内存时，返回的是对应空间大小的虚拟内存地址起始位置的虚拟内存地址，虚拟内存地址指向物理内存地址。物理内存就是实际存储数据的地方。

使用虚拟内存有许多好处。

* 当把内存作为磁盘的DRAM缓存时，通过虚拟化可以更高效地使用内存。
* 可以简化内存地管理。使用虚拟化内存之后，每个进程启动时，都分配一样大小地虚拟内存，代码和数据总是放在固定的位置，或者从相同位置递减进行扩展。代码和静态资源总是放在虚拟内存地地位，堆栈位于虚拟内存地高位。虚拟内存对应的实际物理内存可以是分散在不同的地方。

* 隔离进程之间地地址空间。添加了一层虚拟化，使程序不能直接接触物理内存，进程之间相互隔离。

**当我们要虚拟化资源的时候，或者叫抽象，我们通过干预或者介入对该资源的访问过程来实现这一点。**

虚拟化内存正是通过干预（intercept）物理内存地访问过程实现地虚拟化。实现这个干预和管理的是MMU(memory management unit).

将虚拟化地址转化成物理内存地址（翻译）。虚拟化地址存储在多层级的分页表PTE（page table entry)里。为了实现对PTE的高速访问，现代的内存条都会有一个分页表的缓存TLB(transfer lookaside buffer)。

![image-20210528095623341](https://fuyi-huang.github.io/assets/images/2021-05-25/image-20210528095623341.png)

①CPU发送虚拟内存地址（virtual address）给MMU

②MMU把虚拟地址的VPN（virtual page number，虚拟地址的高n位，除去地位的页内偏移）发送给TLB，看TLB是否有该虚拟地址的页表

③如果有缓存，则返回PTE

④MMU通过PTE找到物理内存地址，去查找存储的数据

⑤把物理内存的数据返回给CPU

![image-20210528100544508](https://fuyi-huang.github.io//assets/images/2021-05-25/image-20210528100544508.png)

这个是虚拟页表查找MISS的情况。

③PTE的address 去物理内存查找PTE

④查到之后写回（write back）到TLB，TLB会选择其中的一个淘汰掉（maybe LRU算法）



## 二、技术栈